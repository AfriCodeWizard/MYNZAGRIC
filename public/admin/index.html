<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Content Manager</title>
</head>
<body>
  <script>
    // COMPLETELY PREVENT Decap CMS from adding #/ to hash
    // Intercept history API and continuously monitor hash
    (function() {
      // Intercept history.pushState and history.replaceState
      const originalPushState = history.pushState;
      const originalReplaceState = history.replaceState;
      
      function fixHashInURL(url) {
        if (!url) return url;
        
        // If URL has a hash, fix it
        const hashIndex = url.indexOf('#');
        if (hashIndex !== -1) {
          const hash = url.substring(hashIndex);
          let fixedHash = hash;
          
          // Remove / after # if present
          if (hash === '#/' || hash === '#') {
            // Remove hash completely
            return url.substring(0, hashIndex);
          } else if (hash.startsWith('#/')) {
            // Remove the / after #
            fixedHash = '#' + hash.substring(2);
            return url.substring(0, hashIndex) + fixedHash;
          }
        }
        return url;
      }
      
      history.pushState = function(state, title, url) {
        url = fixHashInURL(url);
        return originalPushState.call(this, state, title, url);
      };
      
      history.replaceState = function(state, title, url) {
        url = fixHashInURL(url);
        return originalReplaceState.call(this, state, title, url);
      };
      
      // Aggressive continuous monitoring to catch and fix hash changes immediately
      let lastHash = window.location.hash;
      let fixingHash = false;
      
      function fixHash() {
        if (fixingHash) return; // Prevent infinite loops
        fixingHash = true;
        
        const currentHash = window.location.hash;
        
        // If hash is #/ or #, remove it completely
        if (currentHash === '#/' || currentHash === '#') {
          history.replaceState(null, '', window.location.pathname + window.location.search);
        }
        // If hash starts with #/, remove the /
        else if (currentHash.startsWith('#/')) {
          const fixedHash = currentHash.substring(2); // Remove #/
          history.replaceState(null, '', window.location.pathname + window.location.search + '#' + fixedHash);
        }
        
        fixingHash = false;
        lastHash = window.location.hash;
      }
      
      // Monitor hash changes very frequently
      setInterval(fixHash, 5); // Check every 5ms
      
      // Also listen for hashchange events
      window.addEventListener('hashchange', fixHash, true); // Capture phase
      
      // Fix hash immediately on load
      setTimeout(fixHash, 0);
      setTimeout(fixHash, 10);
      setTimeout(fixHash, 50);
      setTimeout(fixHash, 100);
      setTimeout(fixHash, 200);
      setTimeout(fixHash, 500);
      
      // Listen for postMessage from OAuth popup
      window.addEventListener('message', function(event) {
        if (event.origin !== window.location.origin) {
          return;
        }
        
        const data = event.data;
        if (data && (data.token || data.access_token)) {
          const token = data.token || data.access_token;
          
          // Set token in hash with CORRECT format: #access_token=... (NO /)
          // Use history.replaceState to bypass normal hash setter
          history.replaceState(null, '', window.location.pathname + window.location.search + '#access_token=' + encodeURIComponent(token) + '&token_type=bearer');
          
          // Ensure it stays fixed
          setTimeout(fixHash, 10);
          setTimeout(fixHash, 50);
        }
      });
    })();
  </script>
  <script src="https://unpkg.com/netlify-cms@^2.10.0/dist/netlify-cms.js"></script>
</body>
</html>
